<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Dockerfile学习And构建Hexo镜像 | 文心小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="制作一个镜像可以使用docker commit和定制Dockerfile，但推荐的是写Dockerfile。因为docker commit是一个暗箱操作，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，而且会加入一些没用的操作导致镜像臃肿。">
<meta property="og:type" content="article">
<meta property="og:title" content="Dockerfile学习And构建Hexo镜像">
<meta property="og:url" content="https://qxz5637.github.io/2024/05/09/Dockerfile%E5%AD%A6%E4%B9%A0And%E6%9E%84%E5%BB%BAHexo%E9%95%9C%E5%83%8F/index.html">
<meta property="og:site_name" content="文心小屋">
<meta property="og:description" content="制作一个镜像可以使用docker commit和定制Dockerfile，但推荐的是写Dockerfile。因为docker commit是一个暗箱操作，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，而且会加入一些没用的操作导致镜像臃肿。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-09T23:08:36.000Z">
<meta property="article:modified_time" content="2024-05-10T12:10:40.075Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="文心小屋" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">文心小屋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">网络文摘</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qxz5637.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Dockerfile学习And构建Hexo镜像" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/09/Dockerfile%E5%AD%A6%E4%B9%A0And%E6%9E%84%E5%BB%BAHexo%E9%95%9C%E5%83%8F/" class="article-date">
  <time class="dt-published" datetime="2024-05-09T23:08:36.000Z" itemprop="datePublished">2024-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Dockerfile学习And构建Hexo镜像
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="制作一个镜像可以使用docker-commit和定制Dockerfile，但推荐的是写Dockerfile。"><a href="#制作一个镜像可以使用docker-commit和定制Dockerfile，但推荐的是写Dockerfile。" class="headerlink" title="制作一个镜像可以使用docker commit和定制Dockerfile，但推荐的是写Dockerfile。"></a>制作一个镜像可以使用<code>docker commit</code>和定制<code>Dockerfile</code>，但推荐的是写<code>Dockerfile</code>。</h5><h5 id="因为docker-commit是一个暗箱操作，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，而且会加入一些没用的操作导致镜像臃肿。"><a href="#因为docker-commit是一个暗箱操作，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，而且会加入一些没用的操作导致镜像臃肿。" class="headerlink" title="因为docker commit是一个暗箱操作，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，而且会加入一些没用的操作导致镜像臃肿。"></a>因为<code>docker commit</code>是一个暗箱操作，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，而且会加入一些没用的操作导致镜像臃肿。</h5><span id="more"></span>
<h4 id="Build-Images"><a href="#Build-Images" class="headerlink" title="Build Images"></a><code>Build Images</code></h4><h5 id="首先在当前空目录创建一个Dockerfile："><a href="#首先在当前空目录创建一个Dockerfile：" class="headerlink" title="首先在当前空目录创建一个Dockerfile："></a>首先在当前空目录创建一个<code>Dockerfile</code>：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">ENV BLOG_PATH /root/blog</span><br><span class="line">ENV NODE_VERSION 6</span><br><span class="line"></span><br><span class="line">MAINTAINER yangbingdong &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">RUN \</span><br><span class="line">    apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y git curl libpng-dev &amp;&amp; \</span><br><span class="line">    curl -sL https://deb.nodesource.com/setup_$NODE_VERSION.x | bash - &amp;&amp; \</span><br><span class="line">    apt-get install -y nodejs &amp;&amp; \</span><br><span class="line">    apt-get clean &amp;&amp; \</span><br><span class="line">    apt-get autoclean &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* &amp;&amp; \</span><br><span class="line">    npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">WORKDIR $BLOG_PATH</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;$BLOG_PATH&quot;, &quot;/root/.ssh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line">CMD [&#x27;/bin/bash&#x27;]</span><br></pre></td></tr></table></figure>
<h5 id="然后在当前目录打开终端："><a href="#然后在当前目录打开终端：" class="headerlink" title="然后在当前目录打开终端："></a>然后在当前目录打开终端：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;repo-name&gt;/&lt;image-name&gt;:&lt;tag&gt; .</span><br></pre></td></tr></table></figure>
<h5 id="其中表示仓库名，与远程仓库（如docker-hub）名字要一致，表示标签，不给默认latest，都是可选项，例如可以写成这样："><a href="#其中表示仓库名，与远程仓库（如docker-hub）名字要一致，表示标签，不给默认latest，都是可选项，例如可以写成这样：" class="headerlink" title="其中&lt;repo-name&gt;表示仓库名，与远程仓库（如docker hub）名字要一致，&lt;tag&gt;表示标签，不给默认latest，都是可选项，例如可以写成这样："></a>其中<code>&lt;repo-name&gt;</code>表示仓库名，与远程仓库（如<code>docker hub</code>）名字要一致，<code>&lt;tag&gt;</code>表示标签，不给默认<code>latest</code>，都是可选项，例如可以写成这样：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;image-name&gt; .</span><br></pre></td></tr></table></figure>
<h5 id="看到-Successfully-built就表示构建成功了"><a href="#看到-Successfully-built就表示构建成功了" class="headerlink" title="看到 Successfully built就表示构建成功了"></a>看到 <code>Successfully built</code>就表示构建成功了</h5><h5 id="注意docker-build-命令最后有一个-表示构建的上下文，镜像构建需要把上下文的东西上传到Docker引擎去构建。"><a href="#注意docker-build-命令最后有一个-表示构建的上下文，镜像构建需要把上下文的东西上传到Docker引擎去构建。" class="headerlink" title="注意docker build 命令最后有一个 .表示构建的上下文，镜像构建需要把上下文的东西上传到Docker引擎去构建。"></a>注意<code>docker build</code> 命令最后有一个 .表示构建的上下文，镜像构建需要把上下文的东西上传到<code>Docker</code>引擎去构建。</h5><h4 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a><code>Dockerfile</code> 指令</h4><h5 id="From-指定基础镜像"><a href="#From-指定基础镜像" class="headerlink" title="From 指定基础镜像"></a><code>From</code> 指定基础镜像</h5><h5 id="所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而-FROM-就是指定基础镜像，因此一个-Dockerfile-中-FROM-是必备的指令，并且必须是第一条指令。"><a href="#所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而-FROM-就是指定基础镜像，因此一个-Dockerfile-中-FROM-是必备的指令，并且必须是第一条指令。" class="headerlink" title="所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。"></a>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而 FROM 就是指定基础镜像，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</h5><h5 id="在-Docker-Hub上有非常多的高质量的官方镜像，-有可以直接拿来使用的服务类的镜像，如-nginx、redis、mongo、mysql、httpd、php、tomcat-等；-也有一些方便开发、构建、运行各种语言应用的镜像，如-node、openjdk、python、ruby、golang-等。-可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。-如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如-ubuntu、debian、centos、fedora、alpine-等，这些操作系统的软件库为我们提供了更广阔的扩展空间。"><a href="#在-Docker-Hub上有非常多的高质量的官方镜像，-有可以直接拿来使用的服务类的镜像，如-nginx、redis、mongo、mysql、httpd、php、tomcat-等；-也有一些方便开发、构建、运行各种语言应用的镜像，如-node、openjdk、python、ruby、golang-等。-可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。-如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如-ubuntu、debian、centos、fedora、alpine-等，这些操作系统的软件库为我们提供了更广阔的扩展空间。" class="headerlink" title="在 Docker Hub上有非常多的高质量的官方镜像， 有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等； 也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。 可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。"></a>在 <code>Docker Hub</code>上有非常多的高质量的官方镜像， 有可以直接拿来使用的服务类的镜像，如 <code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>httpd</code>、<code>php</code>、<code>tomcat</code> 等； 也有一些方便开发、构建、运行各种语言应用的镜像，如 <code>node</code>、<code>openjdk</code>、<code>python</code>、<code>ruby</code>、<code>golang</code> 等。 可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <code>ubuntu</code>、<code>debian</code>、<code>centos</code>、<code>fedora</code>、<code>alpine</code> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</h5><h5 id="除了选择现有镜像为基础镜像外，Docker-还存在一个特殊的镜像，名为-scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。"><a href="#除了选择现有镜像为基础镜像外，Docker-还存在一个特殊的镜像，名为-scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。" class="headerlink" title="除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。"></a>除了选择现有镜像为基础镜像外，<code>Docker</code> 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</h5><h5 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a><code>RUN</code> 执行命令</h5><h5 id="RUN-指令是用来执行命令行命令的。由于命令行的强大能力，RUN-指令在定制镜像时是最常用的指令之一。其格式有两种："><a href="#RUN-指令是用来执行命令行命令的。由于命令行的强大能力，RUN-指令在定制镜像时是最常用的指令之一。其格式有两种：" class="headerlink" title="RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种："></a><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</h5><h5 id="shell-格式：RUN-，就像直接在命令行中输入的命令一样。刚才写的-Dockrfile-中的-RUN-指令就是这种格式。"><a href="#shell-格式：RUN-，就像直接在命令行中输入的命令一样。刚才写的-Dockrfile-中的-RUN-指令就是这种格式。" class="headerlink" title="shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 RUN 指令就是这种格式。"></a><code>shell</code> 格式：<code>RUN</code> &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 <code>Dockrfile</code> 中的 RUN 指令就是这种格式。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<h5 id="exec-格式：RUN-“可执行文件”-“参数1”-“参数2”-，这更像是函数调用中的格式。"><a href="#exec-格式：RUN-“可执行文件”-“参数1”-“参数2”-，这更像是函数调用中的格式。" class="headerlink" title="exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。"></a><code>exec</code> 格式：<code>RUN</code> [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</h5><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><h5 id="RUN命令尽量精简，也就是像上面一样一个RUN（使用-），如果分开写很多个RUN会导致镜像铺了很多层从而臃肿。"><a href="#RUN命令尽量精简，也就是像上面一样一个RUN（使用-），如果分开写很多个RUN会导致镜像铺了很多层从而臃肿。" class="headerlink" title="RUN命令尽量精简，也就是像上面一样一个RUN（使用$$ \），如果分开写很多个RUN会导致镜像铺了很多层从而臃肿。"></a>RUN命令尽量精简，也就是像上面一样一个RUN（使用$$ \），如果分开写很多个RUN会导致镜像铺了很多层从而臃肿。</h5><h5 id="RUN最后记住清理掉没用的垃圾，很多人初学-Docker-制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。"><a href="#RUN最后记住清理掉没用的垃圾，很多人初学-Docker-制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。" class="headerlink" title="RUN最后记住清理掉没用的垃圾，很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。"></a>RUN最后记住清理掉没用的垃圾，很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</h5><h5 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a><code>COPY</code> 复制文件</h5><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><h5 id="COPY-…"><a href="#COPY-…" class="headerlink" title="COPY &lt;源路径&gt;… &lt;目标路径&gt;"></a><code>COPY</code> &lt;源路径&gt;… &lt;目标路径&gt;</h5><h5 id="COPY-“”-…-“”"><a href="#COPY-“”-…-“”" class="headerlink" title="COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]"></a><code>COPY</code> [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</h5><h5 id="和-RUN-指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。"><a href="#和-RUN-指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。" class="headerlink" title="和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。"></a>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</h5><h5 id="COPY-指令将从构建上下文目录中-的文件-目录复制到新的一层的镜像内的-位置。比如："><a href="#COPY-指令将从构建上下文目录中-的文件-目录复制到新的一层的镜像内的-位置。比如：" class="headerlink" title="COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如："></a><code>COPY</code> 指令将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure>
<h5 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a><code>ADD</code> 更高级的复制文件</h5><h5 id="ADD-指令和-COPY-的格式和性质基本一致。但是在-COPY-基础上增加了一些功能。"><a href="#ADD-指令和-COPY-的格式和性质基本一致。但是在-COPY-基础上增加了一些功能。" class="headerlink" title="ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。"></a><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</h5><h5 id="比如-可以是一个-URL，这种情况下，Docker-引擎会试图去下载这个链接的文件放到-去。下载后的文件权限自动设置为-600，如果这并不是想要的权限，那么还需要增加额外的一层-RUN进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层-RUN-指令进行解压缩。所以不如直接使用-RUN-指令，然后使用-wget-或者-curl-工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。"><a href="#比如-可以是一个-URL，这种情况下，Docker-引擎会试图去下载这个链接的文件放到-去。下载后的文件权限自动设置为-600，如果这并不是想要的权限，那么还需要增加额外的一层-RUN进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层-RUN-指令进行解压缩。所以不如直接使用-RUN-指令，然后使用-wget-或者-curl-工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。" class="headerlink" title="比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。"></a>比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，<code>Docker</code> 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</h5><h5 id="如果-为一个-tar-压缩文件的话，压缩格式为-gzip-bzip2-以及-xz-的情况下，ADD-指令将会自动解压缩这个压缩文件到-去。"><a href="#如果-为一个-tar-压缩文件的话，压缩格式为-gzip-bzip2-以及-xz-的情况下，ADD-指令将会自动解压缩这个压缩文件到-去。" class="headerlink" title="如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。"></a>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</h5><h5 id="在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像-ubuntu-中："><a href="#在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像-ubuntu-中：" class="headerlink" title="在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中："></a>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h5 id="但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用-ADD-命令了。"><a href="#但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用-ADD-命令了。" class="headerlink" title="但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。"></a>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</h5><h5 id="在-Docker-官方的最佳实践文档中要求，尽可能的使用-COPY，因为-COPY-的语义很明确，就是复制文件而已，而-ADD-则包含了更复杂的功能，其行为也不一定很清晰。最适合使用-ADD-的场合，就是所提及的需要自动解压缩的场合。"><a href="#在-Docker-官方的最佳实践文档中要求，尽可能的使用-COPY，因为-COPY-的语义很明确，就是复制文件而已，而-ADD-则包含了更复杂的功能，其行为也不一定很清晰。最适合使用-ADD-的场合，就是所提及的需要自动解压缩的场合。" class="headerlink" title="在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。"></a>在 <code>Docker</code> 官方的最佳实践文档中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</h5><h5 id="另外需要注意的是，ADD-指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。"><a href="#另外需要注意的是，ADD-指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。" class="headerlink" title="另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。"></a>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</h5><h5 id="因此在-COPY-和-ADD-指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用-COPY-指令，仅在需要自动解压缩的场合使用-ADD。"><a href="#因此在-COPY-和-ADD-指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用-COPY-指令，仅在需要自动解压缩的场合使用-ADD。" class="headerlink" title="因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。"></a>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</h5><h5 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a><code>CMD</code> 容器启动命令</h5><h5 id="CMD-指令就是用于指定默认的容器主进程的启动命令的。"><a href="#CMD-指令就是用于指定默认的容器主进程的启动命令的。" class="headerlink" title="CMD 指令就是用于指定默认的容器主进程的启动命令的。"></a><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</h5><h5 id="CMD-指令的格式和-RUN-相似，也是两种格式："><a href="#CMD-指令的格式和-RUN-相似，也是两种格式：" class="headerlink" title="CMD 指令的格式和 RUN 相似，也是两种格式："></a><code>CMD</code> 指令的格式和 RUN 相似，也是两种格式：</h5><h5 id="shell-格式：CMD"><a href="#shell-格式：CMD" class="headerlink" title="shell 格式：CMD &lt;命令&gt;"></a><code>shell</code> 格式：<code>CMD</code> &lt;命令&gt;</h5><h5 id="exec-格式：CMD-“可执行文件”-“参数1”-“参数2”…"><a href="#exec-格式：CMD-“可执行文件”-“参数1”-“参数2”…" class="headerlink" title="exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]"></a><code>exec</code> 格式：<code>CMD</code> [“可执行文件”, “参数1”, “参数2”…]</h5><h5 id="参数列表格式：CMD-“参数1”-“参数2”…-。在指定了-ENTRYPOINT-指令后，用-CMD-指定具体的参数。"><a href="#参数列表格式：CMD-“参数1”-“参数2”…-。在指定了-ENTRYPOINT-指令后，用-CMD-指定具体的参数。" class="headerlink" title="参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。"></a>参数列表格式：<code>CMD</code> [“参数1”, “参数2”…]。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</h5><h5 id="在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu-镜像默认的-CMD-是-bin-bash，如果我们直接-docker-run-it-ubuntu-的话，会直接进入-bash。我们也可以在运行时指定运行别的命令，如-docker-run-it-ubuntu-cat-etc-os-release。这就是用-cat-etc-os-release-命令替换了默认的-bin-bash-命令了，输出了系统版本信息。"><a href="#在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu-镜像默认的-CMD-是-bin-bash，如果我们直接-docker-run-it-ubuntu-的话，会直接进入-bash。我们也可以在运行时指定运行别的命令，如-docker-run-it-ubuntu-cat-etc-os-release。这就是用-cat-etc-os-release-命令替换了默认的-bin-bash-命令了，输出了系统版本信息。" class="headerlink" title="在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。"></a>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release </code>命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</h5><h5 id="在指令格式上，一般推荐使用-exec-格式，这类格式在解析时会被解析为-JSON-数组，因此一定要使用双引号-“，而不要使用单引号。"><a href="#在指令格式上，一般推荐使用-exec-格式，这类格式在解析时会被解析为-JSON-数组，因此一定要使用双引号-“，而不要使用单引号。" class="headerlink" title="在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。"></a>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 <code>JSON</code> 数组，因此一定要使用双引号 “，而不要使用单引号。</h5><h5 id="如果使用-shell-格式的话，实际的命令会被包装为-sh-c-的参数的形式进行执行。比如："><a href="#如果使用-shell-格式的话，实际的命令会被包装为-sh-c-的参数的形式进行执行。比如：" class="headerlink" title="如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如："></a>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure>
<h5 id="在实际执行中，会将其变更为："><a href="#在实际执行中，会将其变更为：" class="headerlink" title="在实际执行中，会将其变更为："></a>在实际执行中，会将其变更为：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure>
<h5 id="所以如果使用shell格式会导致容器莫名退出，因为实际上执行的事sh命令，而sh命令执行完时候容器也就没有存在的意义。"><a href="#所以如果使用shell格式会导致容器莫名退出，因为实际上执行的事sh命令，而sh命令执行完时候容器也就没有存在的意义。" class="headerlink" title="所以如果使用shell格式会导致容器莫名退出，因为实际上执行的事sh命令，而sh命令执行完时候容器也就没有存在的意义。"></a>所以如果使用shell格式会导致容器莫名退出，因为实际上执行的事sh命令，而sh命令执行完时候容器也就没有存在的意义。</h5><h4 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a><code>ENTRYPOINT</code> 入口点</h4><h5 id="ENTRYPOINT-的格式和-RUN-指令格式一样，分为-exec-格式和-shell-格式。"><a href="#ENTRYPOINT-的格式和-RUN-指令格式一样，分为-exec-格式和-shell-格式。" class="headerlink" title="ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。"></a><code>ENTRYPOINT</code> 的格式和 RUN 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</h5><h5 id="ENTRYPOINT-的目的和-CMD-一样，都是在指定容器启动程序及参数。ENTRYPOINT-在运行时也可以替代，不过比-CMD-要略显繁琐，需要通过-docker-run-的参数-entrypoint-来指定。"><a href="#ENTRYPOINT-的目的和-CMD-一样，都是在指定容器启动程序及参数。ENTRYPOINT-在运行时也可以替代，不过比-CMD-要略显繁琐，需要通过-docker-run-的参数-entrypoint-来指定。" class="headerlink" title="ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。"></a><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</h5><h5 id="当指定了-ENTRYPOINT-后，CMD-的含义就发生了改变，不再是直接的运行其命令，而是将-CMD-的内容作为参数传给-ENTRYPOINT-指令，换句话说实际执行时，将变为："><a href="#当指定了-ENTRYPOINT-后，CMD-的含义就发生了改变，不再是直接的运行其命令，而是将-CMD-的内容作为参数传给-ENTRYPOINT-指令，换句话说实际执行时，将变为：" class="headerlink" title="当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为："></a>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>
<h5 id="这个指令非常有用，例如可以把命令后面的参数传进来或启动容器前准备一些环境然后执行启动命令（通过脚本exec-）。"><a href="#这个指令非常有用，例如可以把命令后面的参数传进来或启动容器前准备一些环境然后执行启动命令（通过脚本exec-）。" class="headerlink" title="这个指令非常有用，例如可以把命令后面的参数传进来或启动容器前准备一些环境然后执行启动命令（通过脚本exec &quot;$@&quot;）。"></a>这个指令非常有用，例如可以把命令后面的参数传进来或启动容器前准备一些环境然后执行启动命令（通过脚本<code>exec &quot;$@&quot;</code>）。</h5><h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a><code>ENV</code> 设置环境变量</h4><h5 id="格式有两种："><a href="#格式有两种：" class="headerlink" title="格式有两种："></a>格式有两种：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>
<h5 id="这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如-RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。"><a href="#这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如-RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。" class="headerlink" title="这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。"></a>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ex：</span><br><span class="line"></span><br><span class="line">ENV NODE_VERSION 6</span><br><span class="line">...</span><br><span class="line">RUN curl -sL https://deb.nodesource.com/setup_$NODE_VERSION.x | bash - &amp;&amp; \</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a><code>ARG</code> 构建参数</h4><p>#####格式：<code>ARG</code> &lt;参数名&gt;[&#x3D;&lt;默认值&gt;]</p>
<h5 id="构建参数和-ENV-的效果一样，都是设置环境变量。所不同的是，ARG-所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用-ARG-保存密码之类的信息，因为-docker-history-还是可以看到所有值的。"><a href="#构建参数和-ENV-的效果一样，都是设置环境变量。所不同的是，ARG-所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用-ARG-保存密码之类的信息，因为-docker-history-还是可以看到所有值的。" class="headerlink" title="构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。"></a>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</h5><h5 id="Dockerfile-中的-ARG-指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令-docker-build-中用-build-arg-来覆盖。"><a href="#Dockerfile-中的-ARG-指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令-docker-build-中用-build-arg-来覆盖。" class="headerlink" title="Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。"></a><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg</code> &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。</h5><h5 id="在-1-13-之前的版本，要求-build-arg-中的参数名，必须在-Dockerfile-中用-ARG-定义过了，换句话说，就是-build-arg-指定的参数，必须在-Dockerfile-中使用了。如果对应参数没有被使用，则会报错退出构建。从-1-13-开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用-CI-系统，用同样的构建流程构建不同的-Dockerfile-的时候比较有帮助，避免构建命令必须根据每个-Dockerfile-的内容修改。"><a href="#在-1-13-之前的版本，要求-build-arg-中的参数名，必须在-Dockerfile-中用-ARG-定义过了，换句话说，就是-build-arg-指定的参数，必须在-Dockerfile-中使用了。如果对应参数没有被使用，则会报错退出构建。从-1-13-开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用-CI-系统，用同样的构建流程构建不同的-Dockerfile-的时候比较有帮助，避免构建命令必须根据每个-Dockerfile-的内容修改。" class="headerlink" title="在 1.13 之前的版本，要求 --build-arg 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 --build-arg 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。"></a>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 <code>Dockerfile</code> 的内容修改。</h5><h4 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a><code>VOLUME</code> 定义匿名卷</h4><p>格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>
<h5 id="之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷-volume-中，后面的章节我们会进一步介绍-Docker-卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在-Dockerfile-中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。"><a href="#之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷-volume-中，后面的章节我们会进一步介绍-Docker-卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在-Dockerfile-中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。" class="headerlink" title="之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。"></a>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>
<h5 id="这里的-data-目录就会在运行时自动挂载为匿名卷，任何向-data-中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如："><a href="#这里的-data-目录就会在运行时自动挂载为匿名卷，任何向-data-中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：" class="headerlink" title="这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如："></a>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>
<h5 id="在这行命令中，就使用了-mydata-这个命名卷挂载到了-data-这个位置，替代了-Dockerfile-中定义的匿名卷的挂载配置。"><a href="#在这行命令中，就使用了-mydata-这个命名卷挂载到了-data-这个位置，替代了-Dockerfile-中定义的匿名卷的挂载配置。" class="headerlink" title="在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。"></a>在这行命令中，就使用了<code> mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</h5><h4 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a><code>EXPOSE</code> 声明端口</h4><h5 id="格式为-EXPOSE-…-。"><a href="#格式为-EXPOSE-…-。" class="headerlink" title="格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]。"></a>格式为 <code>EXPOSE</code> &lt;端口1&gt; [&lt;端口2&gt;…]。</h5><h5 id="EXPOSE-指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在-Dockerfile-中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是-docker-run-P时，会自动随机映射-EXPOSE-的端口。"><a href="#EXPOSE-指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在-Dockerfile-中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是-docker-run-P时，会自动随机映射-EXPOSE-的端口。" class="headerlink" title="EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P时，会自动随机映射 EXPOSE 的端口。"></a><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 <code>Dockerfile</code> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code>时，会自动随机映射 <code>EXPOSE</code> 的端口。</h5><h5 id="此外，在早期-Docker-版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个-Docker-引擎参数-icc-false，当指定该参数后，容器间将默认无法互访，除非互相间使用了-–links-参数的容器才可以互通，并且只有镜像中-EXPOSE-所声明的端口才可以被访问。这个-icc-false-的用法，在引入了-docker-network后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。"><a href="#此外，在早期-Docker-版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个-Docker-引擎参数-icc-false，当指定该参数后，容器间将默认无法互访，除非互相间使用了-–links-参数的容器才可以互通，并且只有镜像中-EXPOSE-所声明的端口才可以被访问。这个-icc-false-的用法，在引入了-docker-network后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。" class="headerlink" title="此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 --icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 –links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 --icc=false 的用法，在引入了 docker network后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。"></a>此外，在早期 <code>Docker</code> 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 <code>Docker</code> 引擎参数 <code>--icc=false</code>，当指定该参数后，容器间将默认无法互访，除非互相间使用了 –links 参数的容器才可以互通，并且只有镜像中 <code>EXPOSE</code> 所声明的端口才可以被访问。这个 <code>--icc=false</code> 的用法，在引入了 <code>docker network</code>后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</h5><h5 id="要将-EXPOSE-和在运行时使用-p-区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而-EXPOSE-仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。"><a href="#要将-EXPOSE-和在运行时使用-p-区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而-EXPOSE-仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。" class="headerlink" title="要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。"></a>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p</code> &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</h5><h4 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a><code>WORKDIR</code> 指定工作目录</h4><h5 id="格式为-WORKDIR-。"><a href="#格式为-WORKDIR-。" class="headerlink" title="格式为 WORKDIR &lt;工作目录路径&gt;。"></a>格式为 <code>WORKDIR</code> &lt;工作目录路径&gt;。</h5><h5 id="使用-WORKDIR-指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR-会帮你建立目录。"><a href="#使用-WORKDIR-指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR-会帮你建立目录。" class="headerlink" title="使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。"></a>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</h5><h5 id="之前提到一些初学者常犯的错误是把-Dockerfile-等同于-Shell-脚本来书写，这种错误的理解还可能会导致出现下面这样的错误："><a href="#之前提到一些初学者常犯的错误是把-Dockerfile-等同于-Shell-脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：" class="headerlink" title="之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误："></a>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 <code>Shell</code> 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd /app</span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure>
<h5 id="如果将这个-Dockerfile-进行构建镜像运行后，会发现找不到-app-world-txt-文件，或者其内容不是-hello。原因其实很简单，在-Shell-中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在-Dockerfile-中，这两行-RUN-命令的执行环境根本不同，是两个完全不同的容器。这就是对-Dokerfile-构建分层存储的概念不了解所导致的错误。"><a href="#如果将这个-Dockerfile-进行构建镜像运行后，会发现找不到-app-world-txt-文件，或者其内容不是-hello。原因其实很简单，在-Shell-中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在-Dockerfile-中，这两行-RUN-命令的执行环境根本不同，是两个完全不同的容器。这就是对-Dokerfile-构建分层存储的概念不了解所导致的错误。" class="headerlink" title="如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。"></a>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 <code>Shell</code> 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dokerfile</code> 构建分层存储的概念不了解所导致的错误。</h5><h5 id="之前说过每一个-RUN-都是启动一个容器、执行命令、然后提交存储层文件变更。第一层-RUN-cd-app-的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。"><a href="#之前说过每一个-RUN-都是启动一个容器、执行命令、然后提交存储层文件变更。第一层-RUN-cd-app-的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。" class="headerlink" title="之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。"></a>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</h5><h5 id="因此如果需要改变以后各层的工作目录的位置，那么应该使用-WORKDIR-指令。"><a href="#因此如果需要改变以后各层的工作目录的位置，那么应该使用-WORKDIR-指令。" class="headerlink" title="因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。"></a>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</h5><h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a><code>USER</code> 指定当前用户</h4><h5 id="格式：USER"><a href="#格式：USER" class="headerlink" title="格式：USER &lt;用户名&gt;"></a>格式：<code>USER</code> &lt;用户名&gt;</h5><h5 id="USER-指令和-WORKDIR-相似，都是改变环境状态并影响以后的层。WORKDIR-是改变工作目录，USER则是改变之后层的执行-RUN-CMD-以及-ENTRYPOINT-这类命令的身份。"><a href="#USER-指令和-WORKDIR-相似，都是改变环境状态并影响以后的层。WORKDIR-是改变工作目录，USER则是改变之后层的执行-RUN-CMD-以及-ENTRYPOINT-这类命令的身份。" class="headerlink" title="USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。"></a><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code>则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</h5><h5 id="当然，和-WORKDIR-一样，USER-只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。"><a href="#当然，和-WORKDIR-一样，USER-只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。" class="headerlink" title="当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。"></a>当然，和 <code>WORKDIR</code> 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure>
<h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><h5 id="Dockerfile里也需要注意权限问题（nodejs7版本以上不能正常安装hexo，需要创建用户并制定权限去安装）"><a href="#Dockerfile里也需要注意权限问题（nodejs7版本以上不能正常安装hexo，需要创建用户并制定权限去安装）" class="headerlink" title="Dockerfile里也需要注意权限问题（nodejs7版本以上不能正常安装hexo，需要创建用户并制定权限去安装）"></a><code>Dockerfile</code>里也需要注意权限问题（<code>nodejs</code>7版本以上不能正常安装<code>hexo</code>，需要创建用户并制定权限去安装）</h5><h5 id="在docker容器里如果是root用户对挂载的文件进行了操作，那么实际上挂载文件的权限也变成了root的"><a href="#在docker容器里如果是root用户对挂载的文件进行了操作，那么实际上挂载文件的权限也变成了root的" class="headerlink" title="在docker容器里如果是root用户对挂载的文件进行了操作，那么实际上挂载文件的权限也变成了root的"></a>在<code>docker</code>容器里如果是<code>root</code>用户对挂载的文件进行了操作，那么实际上挂载文件的权限也变成了<code>root</code>的</h5><h5 id="使用attach进入容器，退出的时候容器也跟着退出了。。。囧"><a href="#使用attach进入容器，退出的时候容器也跟着退出了。。。囧" class="headerlink" title="使用attach进入容器，退出的时候容器也跟着退出了。。。囧"></a>使用<code>attach</code>进入容器，退出的时候容器也跟着退出了。。。囧</h5><h5 id="每一个RUN是一个新的shell"><a href="#每一个RUN是一个新的shell" class="headerlink" title="每一个RUN是一个新的shell"></a>每一个<code>RUN</code>是一个新的<code>shell</code></h5><h5 id="su-之前在启动脚本加了-，导致环境变量以及工作目录都变了"><a href="#su-之前在启动脚本加了-，导致环境变量以及工作目录都变了" class="headerlink" title="su -之前在启动脚本加了-，导致环境变量以及工作目录都变了"></a><code>su -</code>之前在启动脚本加了<code>-</code>，导致环境变量以及工作目录都变了</h5><h4 id="Hexo-Docker"><a href="#Hexo-Docker" class="headerlink" title="Hexo-Docker"></a><code>Hexo-Docker</code></h4><h5 id="最后献上踩坑写的Hexo-Dockerfile"><a href="#最后献上踩坑写的Hexo-Dockerfile" class="headerlink" title="最后献上踩坑写的Hexo Dockerfile:"></a>最后献上踩坑写的Hexo Dockerfile:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"># 使用Ubuntu官方镜像</span><br><span class="line"></span><br><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line"># 作者信息</span><br><span class="line">MAINTAINER yangbingdong &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"># 设置环境变量，使用$&#123;变量名&#125;取值</span><br><span class="line">ENV \</span><br><span class="line">    USER_NAME=hexo \</span><br><span class="line">    NODE_VERSION=8.5.0 \</span><br><span class="line">    NODE_DIR=/home/$&#123;USER_NAME&#125;/nodejs</span><br><span class="line"></span><br><span class="line"># 需要执行的命令，使用 `$$ \` 分割多行多个命令</span><br><span class="line">RUN \</span><br><span class="line">    # 安装基本的依赖以及工具</span><br><span class="line">    apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get upgrade -y &amp;&amp; \</span><br><span class="line">    apt-get install -y git &amp;&amp; \</span><br><span class="line">    apt-get install -y curl &amp;&amp; \</span><br><span class="line">    apt-get install -y libpng-dev &amp;&amp; \</span><br><span class="line">    # 清理不必要的垃圾</span><br><span class="line">    apt-get clean &amp;&amp; \</span><br><span class="line">    apt-get autoclean &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* &amp;&amp; \</span><br><span class="line">    # 创建hexo用户去安装hexo</span><br><span class="line">    useradd -m -U $&#123;USER_NAME&#125; &amp;&amp; \</span><br><span class="line">    # 创建nodejs目录</span><br><span class="line">    mkdir $&#123;NODE_DIR&#125; &amp;&amp; \</span><br><span class="line">    # 将nodejs下载解压到对应目录</span><br><span class="line">    curl -L https://nodejs.org/dist/v$&#123;NODE_VERSION&#125;/node-v$&#123;NODE_VERSION&#125;-linux-x64.tar.gz | tar xvzf - -C $&#123;NODE_DIR&#125; --strip-components=1 &amp;&amp; \</span><br><span class="line">    # 把nodejs文件赋权给hexo用户</span><br><span class="line">    chown -R $&#123;USER_NAME&#125;.$&#123;USER_NAME&#125; $&#123;NODE_DIR&#125; &amp;&amp; \</span><br><span class="line">    # 把node相关命令软连接到/usr/local/bin目录下以便我们使用</span><br><span class="line">    ln -s $&#123;NODE_DIR&#125;/bin/node /usr/local/bin/node &amp;&amp; \</span><br><span class="line">    ln -s $&#123;NODE_DIR&#125;/bin/npm /usr/local/bin/npm &amp;&amp; \</span><br><span class="line">    # 以hexo用户身份安装hexo-cli</span><br><span class="line">    su - $&#123;USER_NAME&#125; -c &quot;npm install -g hexo-cli&quot; &amp;&amp; \</span><br><span class="line">    # 同样把hexo命令放到/usr/local/bin下</span><br><span class="line">    ln -s $&#123;NODE_DIR&#125;/bin/hexo /usr/local/bin/hexo &amp;&amp; \</span><br><span class="line">    # 使用淘宝镜像</span><br><span class="line">    npm config set registry https://registry.npm.taobao.org/</span><br><span class="line"></span><br><span class="line"># 切换到此目录</span><br><span class="line">WORKDIR /home/$&#123;USER_NAME&#125;/blog</span><br><span class="line"></span><br><span class="line"># 可以挂载进来的卷（文件夹）</span><br><span class="line">VOLUME [&quot;/home/$&#123;USER_NAME&#125;/blog&quot;, &quot;/home/$&#123;USER_NAME&#125;/.ssh&quot;]</span><br><span class="line"></span><br><span class="line"># 暴露端口</span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line"># 把上下文中的docker-entrypoint.sh复制进来</span><br><span class="line">COPY docker-entrypoint.sh /docker-entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 执行脚本</span><br><span class="line">ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line"># 这个...鸡肋操作</span><br><span class="line">CMD [&#x27;/bin/bash&#x27;]</span><br><span class="line">docker-entrypoint.sh :</span><br><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># 发生异常回滚</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"># 设置git相关信息，不设置默认为博主的=.=</span><br><span class="line">GIT_USER_NAME=$&#123;GIT_USER_NAME:-yangbingdong&#125;</span><br><span class="line"></span><br><span class="line">GIT_USER_MAIL=$&#123;GIT_USER_MAIL:-yangbingdong1994@gmail.com&#125;</span><br><span class="line"></span><br><span class="line"># 你想要的用户名</span><br><span class="line">NEW_USER_NAME=$&#123;NEW_USER_NAME:-ybd&#125;</span><br><span class="line"></span><br><span class="line"># 由于每次启动容器都会执行这个脚本，但这个只需要执行一次，在此标志一下</span><br><span class="line">if [ $(git config --system user.name)x = $&#123;GIT_USER_NAME&#125;x ]</span><br><span class="line">then</span><br><span class="line">    su $&#123;NEW_USER_NAME&#125;</span><br><span class="line">else</span><br><span class="line">    # 修改用户名</span><br><span class="line">    /usr/sbin/usermod -l $&#123;NEW_USER_NAME&#125; $&#123;USER_NAME&#125;</span><br><span class="line"></span><br><span class="line">    /usr/sbin/usermod -c $&#123;NEW_USER_NAME&#125; $&#123;NEW_USER_NAME&#125;</span><br><span class="line"></span><br><span class="line">    /usr/sbin/groupmod -n $&#123;NEW_USER_NAME&#125; $&#123;USER_NAME&#125;</span><br><span class="line"></span><br><span class="line">    chown -R $&#123;NEW_USER_NAME&#125;.$&#123;NEW_USER_NAME&#125; /home/$&#123;USER_NAME&#125;/blog</span><br><span class="line"></span><br><span class="line">    chmod -R 766 /home/$&#123;USER_NAME&#125;/blog</span><br><span class="line">    </span><br><span class="line">    # 设置git全局信息</span><br><span class="line">    git config --system user.name $GIT_USER_NAME</span><br><span class="line"></span><br><span class="line">    git config --system user.email $GIT_USER_MAIL</span><br><span class="line"></span><br><span class="line">    su $&#123;NEW_USER_NAME&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 执行脚本之后的命令</span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<h5 id="源码：https-github-com-masteranthoneyd-docker-hexo"><a href="#源码：https-github-com-masteranthoneyd-docker-hexo" class="headerlink" title="源码：https://github.com/masteranthoneyd/docker-hexo"></a>源码：<a target="_blank" rel="noopener" href="https://github.com/masteranthoneyd/docker-hexo">https://github.com/masteranthoneyd/docker-hexo</a></h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://qxz5637.github.io/2024/05/09/Dockerfile%E5%AD%A6%E4%B9%A0And%E6%9E%84%E5%BB%BAHexo%E9%95%9C%E5%83%8F/" data-id="clw98lang0000lvp8dh1rfaud" data-title="Dockerfile学习And构建Hexo镜像" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/05/10/Hexo-Blog-Docker%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hexo-Blog Docker搭建本地环境与持续集成
        
      </div>
    </a>
  
  
    <a href="/2024/05/06/%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E5%90%8E%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85%E9%95%9C%E5%83%8F%E5%B9%B6%E4%B8%8A%E4%BC%A0%E8%87%B3%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">修改容器后重新打包镜像并上传至镜像仓库</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/16/%E4%BD%BF%E7%94%A8key%E5%85%8D%E5%AF%86rsync%E5%90%8C%E6%AD%A5/">使用key免密rsync同步</a>
          </li>
        
          <li>
            <a href="/2024/05/14/Docker%E5%88%A9%E7%94%A8busybox%E5%88%9B%E5%BB%BA%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F/">Docker利用busybox创建基础镜像</a>
          </li>
        
          <li>
            <a href="/2024/05/10/Hexo-Blog-Docker%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">Hexo-Blog Docker搭建本地环境与持续集成</a>
          </li>
        
          <li>
            <a href="/2024/05/09/Dockerfile%E5%AD%A6%E4%B9%A0And%E6%9E%84%E5%BB%BAHexo%E9%95%9C%E5%83%8F/">Dockerfile学习And构建Hexo镜像</a>
          </li>
        
          <li>
            <a href="/2024/05/06/%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E5%90%8E%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85%E9%95%9C%E5%83%8F%E5%B9%B6%E4%B8%8A%E4%BC%A0%E8%87%B3%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/">修改容器后重新打包镜像并上传至镜像仓库</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 文心小屋<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>